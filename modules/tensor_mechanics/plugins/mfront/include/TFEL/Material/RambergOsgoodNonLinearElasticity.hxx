/*!
* \file   TFEL/Material/RambergOsgoodNonLinearElasticity.hxx
* \brief  this file implements the RambergOsgoodNonLinearElasticity Behaviour.
*         File generated by tfel version 4.0.0-dev
* \author L . Gelebart / V . Duc Nguyen
 */

#ifndef LIB_TFELMATERIAL_RAMBERGOSGOODNONLINEARELASTICITY_HXX
#define LIB_TFELMATERIAL_RAMBERGOSGOODNONLINEARELASTICITY_HXX

#include<string>
#include<iostream>
#include<limits>
#include<stdexcept>
#include<algorithm>

#include"TFEL/Raise.hxx"
#include"TFEL/PhysicalConstants.hxx"
#include"TFEL/Config/TFELConfig.hxx"
#include"TFEL/Config/TFELTypes.hxx"
#include"TFEL/TypeTraits/IsFundamentalNumericType.hxx"
#include"TFEL/TypeTraits/IsReal.hxx"
#include"TFEL/Math/General/IEEE754.hxx"
#include"TFEL/Material/MaterialException.hxx"
#include"TFEL/Material/MechanicalBehaviour.hxx"
#include"TFEL/Material/MechanicalBehaviourTraits.hxx"
#include"TFEL/Material/OutOfBoundsPolicy.hxx"
#include"TFEL/Material/BoundsCheck.hxx"
#include"TFEL/Material/IsotropicPlasticity.hxx"
#include"TFEL/Material/Lame.hxx"
#include"TFEL/Material/Hosford1972YieldCriterion.hxx"
#include"TFEL/Material/RambergOsgoodNonLinearElasticityBehaviourData.hxx"
#include"TFEL/Material/RambergOsgoodNonLinearElasticityIntegrationData.hxx"

#include "MFront/GenericBehaviour/State.hxx"
#include "MFront/GenericBehaviour/BehaviourData.hxx"
namespace tfel::material{

struct RambergOsgoodNonLinearElasticityParametersInitializer
{
static RambergOsgoodNonLinearElasticityParametersInitializer&
get();

double e_tum_03B5__;
double minimal_time_step_scaling_factor;
double maximal_time_step_scaling_factor;

void set(const char* const,const double);

/*!
 * \brief convert a string to double
 * \param[in] p : parameter
 * \param[in] v : value
 */
static double getDouble(const std::string&,const std::string&);
private :

RambergOsgoodNonLinearElasticityParametersInitializer();

RambergOsgoodNonLinearElasticityParametersInitializer(const RambergOsgoodNonLinearElasticityParametersInitializer&);

RambergOsgoodNonLinearElasticityParametersInitializer&
operator=(const RambergOsgoodNonLinearElasticityParametersInitializer&);
/*!
 * \brief read the parameters from the given file
 * \param[out] pi : parameters initializer
 * \param[in]  fn : file name
 */
static void readParameters(RambergOsgoodNonLinearElasticityParametersInitializer&,const char* const);
};

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis, typename NumericType, bool use_qt>
class RambergOsgoodNonLinearElasticity;

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis hypothesis, typename NumericType>
std::ostream&
 operator <<(std::ostream&,const RambergOsgoodNonLinearElasticity<hypothesis, NumericType, false>&);

/*!
* \class RambergOsgoodNonLinearElasticity
* \brief This class implements the RambergOsgoodNonLinearElasticity behaviour.
* \tparam hypothesis: modelling hypothesis.
* \tparam NumericType: numerical type.
* \author L . Gelebart / V . Duc Nguyen
* Ramberg-Osgood model (non-(linear elastic formulation) 
* Eps = S:Sig +β.σ_eq^n. N 
* with: 
*  - N = (3/2) Sig_dev / σ_eq 
*  - σ_eq = rac((3/2)σ_dev:σ_dev)) 
*  - β = α⋅σ₀/E 
*/
template<ModellingHypothesis::Hypothesis hypothesis,typename NumericType>
struct RambergOsgoodNonLinearElasticity<hypothesis, NumericType, false> final
: public MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>,
public RambergOsgoodNonLinearElasticityBehaviourData<hypothesis, NumericType, false>,
public RambergOsgoodNonLinearElasticityIntegrationData<hypothesis, NumericType, false>
{

static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;

static_assert(N==1||N==2||N==3);
static_assert(tfel::typetraits::IsFundamentalNumericType<NumericType>::cond);
static_assert(tfel::typetraits::IsReal<NumericType>::cond);

friend std::ostream& operator<< <>(std::ostream&,const RambergOsgoodNonLinearElasticity&);

static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;

using ushort =  unsigned short;
using Types = tfel::config::Types<N, NumericType, false>;
using Type = NumericType;
using real = typename Types::real;
using time = typename Types::time;
using length = typename Types::length;
using frequency = typename Types::frequency;
using speed = typename Types::speed;
using stress = typename Types::stress;
using strain = typename Types::strain;
using strainrate = typename Types::strainrate;
using stressrate = typename Types::stressrate;
using temperature = typename Types::temperature;
using thermalexpansion = typename Types::thermalexpansion;
using thermalconductivity = typename Types::thermalconductivity;
using massdensity = typename Types::massdensity;
using energydensity = typename Types::energydensity;
using TVector = typename Types::TVector;
using DisplacementTVector = typename Types::DisplacementTVector;
using ForceTVector = typename Types::ForceTVector;
using HeatFlux = typename Types::HeatFlux;
using TemperatureGradient = typename Types::TemperatureGradient;
using Stensor = typename Types::Stensor;
using StressStensor = typename Types::StressStensor;
using StressRateStensor = typename Types::StressRateStensor;
using StrainStensor = typename Types::StrainStensor;
using StrainRateStensor = typename Types::StrainRateStensor;
using FrequencyStensor = typename Types::FrequencyStensor;
using Tensor = typename Types::Tensor;
using DeformationGradientTensor = typename Types::DeformationGradientTensor;
using StressTensor = typename Types::StressTensor;
using StiffnessTensor = typename Types::StiffnessTensor;
using Stensor4 = typename Types::Stensor4;
using TangentOperator = StiffnessTensor;
using PhysicalConstants = tfel::PhysicalConstants<NumericType, false>;

public :

typedef RambergOsgoodNonLinearElasticityBehaviourData<hypothesis, NumericType, false> BehaviourData;
typedef RambergOsgoodNonLinearElasticityIntegrationData<hypothesis, NumericType, false> IntegrationData;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::SMFlag SMFlag;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::SMType SMType;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::ELASTIC;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::SECANTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::TANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::CONSISTENTTANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::NOSTIFFNESSREQUESTED;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::STANDARDTANGENTOPERATOR;
using IntegrationResult = typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::IntegrationResult;

using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::SUCCESS;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::FAILURE;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::UNRELIABLE_RESULTS;

using StressFreeExpansionType = StrainStensor;

private :



#line 38 "RambergOsgoodNonLinearElasticity.mfront"
stress dtum_03C3__tum_2091__;

#line 30 "RambergOsgoodNonLinearElasticity.mfront"
stress tum_03BC__;
#line 32 "RambergOsgoodNonLinearElasticity.mfront"
stress K;
#line 34 "RambergOsgoodNonLinearElasticity.mfront"
real tum_03B2__;
#line 46 "RambergOsgoodNonLinearElasticity.mfront"
stress tum_2202__tum_03C3__tum_2091__tum_2215__tum_2202__tum_03B5__tum_2091__;
#line 48 "RambergOsgoodNonLinearElasticity.mfront"
strain tum_03B5__tum_2091__;
#line 50 "RambergOsgoodNonLinearElasticity.mfront"
real itum_03B5__tum_2091__;
#line 52 "RambergOsgoodNonLinearElasticity.mfront"
StrainStensor ne;

#line 26 "RambergOsgoodNonLinearElasticity.mfront"
real e_tum_03B5__;
time minimal_time_step_scaling_factor;
time maximal_time_step_scaling_factor;

//! Tangent operator;
TangentOperator Dt;
//! alias to the tangent operator;
TangentOperator& dsig_ddeto;
/*!
* \brief Update internal variables at end of integration
*/
void updateIntegrationVariables(){
}

/*!
* \brief Update internal variables at end of integration
*/
void updateStateVariables(){
this->tum_03C3__tum_2091__ += this->dtum_03C3__tum_2091__;
}

/*!
* \brief Update auxiliary state variables at end of integration
*/
void updateAuxiliaryStateVariables()
{}

//! \brief Default constructor (disabled)
RambergOsgoodNonLinearElasticity() =delete ;
//! \brief Copy constructor (disabled)
RambergOsgoodNonLinearElasticity(const RambergOsgoodNonLinearElasticity&) = delete;
//! \brief Assignement operator (disabled)
RambergOsgoodNonLinearElasticity& operator = (const RambergOsgoodNonLinearElasticity&) = delete;

public:

/*!
* \brief Constructor
*/
RambergOsgoodNonLinearElasticity(const RambergOsgoodNonLinearElasticityBehaviourData<hypothesis, NumericType, false>& src1,
const RambergOsgoodNonLinearElasticityIntegrationData<hypothesis, NumericType, false>& src2)
: RambergOsgoodNonLinearElasticityBehaviourData<hypothesis, NumericType, false>(src1),
RambergOsgoodNonLinearElasticityIntegrationData<hypothesis, NumericType, false>(src2),
dtum_03C3__tum_2091__(stress(0)),
dsig_ddeto(Dt)
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->e_tum_03B5__ = RambergOsgoodNonLinearElasticityParametersInitializer::get().e_tum_03B5__;
this->minimal_time_step_scaling_factor = RambergOsgoodNonLinearElasticityParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = RambergOsgoodNonLinearElasticityParametersInitializer::get().maximal_time_step_scaling_factor;
}

/*
 * \brief constructor for the Generic interface
 * \param[in] mgb_d: behaviour data
 */
RambergOsgoodNonLinearElasticity(const mfront::gb::BehaviourData& mgb_d)
: RambergOsgoodNonLinearElasticityBehaviourData<hypothesis, NumericType, false>(mgb_d),
RambergOsgoodNonLinearElasticityIntegrationData<hypothesis, NumericType, false>(mgb_d),
dtum_03C3__tum_2091__(stress(0)),
dsig_ddeto(Dt)
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->e_tum_03B5__ = RambergOsgoodNonLinearElasticityParametersInitializer::get().e_tum_03B5__;
this->minimal_time_step_scaling_factor = RambergOsgoodNonLinearElasticityParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = RambergOsgoodNonLinearElasticityParametersInitializer::get().maximal_time_step_scaling_factor;
this-> eto = tfel::math::map<StrainStensor>(mgb_d.s0.gradients);
tfel::fsalgo::transform<StensorSize>::exe(mgb_d.s1.gradients,mgb_d.s0.gradients,this->deto.begin(),std::minus<real>());
this-> sig = tfel::math::map<StressStensor>(mgb_d.s0.thermodynamic_forces);
}

/*!
 * \ brief initialize the behaviour with user code
 */
void initialize(){
using namespace std;
using namespace tfel::math;
using std::vector;
#line 55 "RambergOsgoodNonLinearElasticity.mfront"
this->tum_03BC__ = computeMu(this->E, this->tum_03BD__);
#line 56 "RambergOsgoodNonLinearElasticity.mfront"
this->K = this->E / (3 * (1 - 2 * this->tum_03BD__));
#line 57 "RambergOsgoodNonLinearElasticity.mfront"
this->tum_03B2__ = this->tum_03B1__ * this->tum_03C3__tum_2080__ / this->E;
#line 59 "RambergOsgoodNonLinearElasticity.mfront"
this->tum_2202__tum_03C3__tum_2091__tum_2215__tum_2202__tum_03B5__tum_2091__ = stress{};
}

/*!
* \brief set the policy for "out of bounds" conditions
*/
void
setOutOfBoundsPolicy(const OutOfBoundsPolicy policy_value){
this->policy = policy_value;
} // end of setOutOfBoundsPolicy

/*!
* \return the modelling hypothesis
*/
constexpr ModellingHypothesis::Hypothesis
getModellingHypothesis() const{
return hypothesis;
} // end of getModellingHypothesis

/*!
* \brief check bounds
*/
void checkBounds() const{
} // end of checkBounds

IntegrationResult
computePredictionOperator(const SMFlag smflag,const SMType smt) override{
using namespace std;
using namespace tfel::math;
using std::vector;
tfel::raise_if(smflag!=MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::STANDARDTANGENTOPERATOR,
"invalid prediction operator flag");
#line 63 "RambergOsgoodNonLinearElasticity.mfront"
static_cast<void>(smt);
#line 64 "RambergOsgoodNonLinearElasticity.mfront"
const auto P = Stensor4::Id() - (Stensor::Id() ^ Stensor::Id()) / 3;
#line 65 "RambergOsgoodNonLinearElasticity.mfront"
(this->Dt) = (this->K) * (Stensor::Id() ^ Stensor::Id()) + 2 * (this->tum_03BC__) * P;return SUCCESS;
}

time getMinimalTimeStepScalingFactor() const noexcept override{
  return this->minimal_time_step_scaling_factor;
}

std::pair<bool, time>
computeAPrioriTimeStepScalingFactor(const time current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPrioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                  current_time_step_scaling_factor)};
}

/*!
* \brief Integrate behaviour  over the time step
*/
IntegrationResult
integrate(const SMFlag smflag, const SMType smt) override{
using namespace std;
using namespace tfel::math;
raise_if(smflag!=MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::STANDARDTANGENTOPERATOR,
"invalid tangent operator flag");
bool computeTangentOperator_ = smt!=NOSTIFFNESSREQUESTED;
#line 69 "RambergOsgoodNonLinearElasticity.mfront"
const auto tum_03B5__ = this->eto + this->deto;
#line 70 "RambergOsgoodNonLinearElasticity.mfront"
const auto se = deviator(tum_03B5__);
#line 71 "RambergOsgoodNonLinearElasticity.mfront"
this->tum_03B5__tum_2091__ = sqrt(2 * (se | se) / 3);
#line 72 "RambergOsgoodNonLinearElasticity.mfront"
this->itum_03B5__tum_2091__ = 1 / max(this->tum_03B5__tum_2091__, this->e_tum_03B5__);
#line 73 "RambergOsgoodNonLinearElasticity.mfront"
this->ne = 2 * se * (this->itum_03B5__tum_2091__ / 3);
#line 75 "RambergOsgoodNonLinearElasticity.mfront"
if (this->tum_03B5__tum_2091__ < this->e_tum_03B5__) {
#line 76 "RambergOsgoodNonLinearElasticity.mfront"
this->tum_03C3__tum_2091__ = 3 * this->tum_03BC__ * this->tum_03B5__tum_2091__;
#line 77 "RambergOsgoodNonLinearElasticity.mfront"
this->tum_2202__tum_03C3__tum_2091__tum_2215__tum_2202__tum_03B5__tum_2091__ = 3 * this->tum_03BC__;
#line 78 "RambergOsgoodNonLinearElasticity.mfront"
} else {
#line 79 "RambergOsgoodNonLinearElasticity.mfront"
const auto e_tum_03C3__ = this->E * this->e_tum_03B5__;
#line 80 "RambergOsgoodNonLinearElasticity.mfront"
const auto i3tum_03BC__ = 1 / (3 * this->tum_03BC__);
#line 81 "RambergOsgoodNonLinearElasticity.mfront"
auto f = real{};
#line 82 "RambergOsgoodNonLinearElasticity.mfront"
auto fidf = [&]() {
#line 83 "RambergOsgoodNonLinearElasticity.mfront"
const auto rtum_03C3__tum_2091__tum_207F__ = pow(this->tum_03C3__tum_2091__ / this->tum_03C3__tum_2080__, this->n);
#line 84 "RambergOsgoodNonLinearElasticity.mfront"
const auto itum_03C3__tum_2091__ = 1 / max(e_tum_03C3__, this->tum_03C3__tum_2091__);
#line 85 "RambergOsgoodNonLinearElasticity.mfront"
f = this->tum_03C3__tum_2091__ * i3tum_03BC__ + this->tum_03B2__ * rtum_03C3__tum_2091__tum_207F__ - this->tum_03B5__tum_2091__;
#line 86 "RambergOsgoodNonLinearElasticity.mfront"
this->tum_2202__tum_03C3__tum_2091__tum_2215__tum_2202__tum_03B5__tum_2091__ = 1 / max(i3tum_03BC__ + this->n * this->tum_03B2__ * rtum_03C3__tum_2091__tum_207F__ * itum_03C3__tum_2091__, i3tum_03BC__ * this->e_tum_03B5__);
#line 87 "RambergOsgoodNonLinearElasticity.mfront"
};
#line 88 "RambergOsgoodNonLinearElasticity.mfront"
this->tum_03C3__tum_2091__ = this->tum_03C3__tum_2080__ * pow(this->tum_03B5__tum_2091__ / this->tum_03B2__, 1 / this->n);
#line 89 "RambergOsgoodNonLinearElasticity.mfront"
auto iter = int{};
#line 90 "RambergOsgoodNonLinearElasticity.mfront"
fidf();
#line 91 "RambergOsgoodNonLinearElasticity.mfront"
while (abs(f) > this->e_tum_03B5__) {
#line 92 "RambergOsgoodNonLinearElasticity.mfront"
this->tum_03C3__tum_2091__ -= f * this->tum_2202__tum_03C3__tum_2091__tum_2215__tum_2202__tum_03B5__tum_2091__;
#line 93 "RambergOsgoodNonLinearElasticity.mfront"
fidf();
#line 94 "RambergOsgoodNonLinearElasticity.mfront"
if (++iter > 20) {
#line 95 "RambergOsgoodNonLinearElasticity.mfront"
throw(DivergenceException());
#line 96 "RambergOsgoodNonLinearElasticity.mfront"
}
#line 97 "RambergOsgoodNonLinearElasticity.mfront"
}
#line 98 "RambergOsgoodNonLinearElasticity.mfront"
}
#line 100 "RambergOsgoodNonLinearElasticity.mfront"
this->sig = this->K * trace(tum_03B5__) * Stensor::Id() + this->tum_03C3__tum_2091__ * this->ne;
this->updateIntegrationVariables();
this->updateStateVariables();
this->updateAuxiliaryStateVariables();
if(computeTangentOperator_){
if(!this->computeConsistentTangentOperator(smt)){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::FAILURE;
}
}
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::SUCCESS;
}

std::pair<bool, time>
computeAPosterioriTimeStepScalingFactor(const time current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPosterioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                 current_time_step_scaling_factor)};
}

/*!
* \brief Update the internal energy at end of the time step
* \param[in] Psi_s: internal energy at end of the time step
*/
void computeInternalEnergy(real& Psi_s) const
{
Psi_s=0;
}

/*!
* \brief Update the dissipated energy at end of the time step
* \param[in] Psi_d: dissipated energy at end of the time step
*/
void computeDissipatedEnergy(real& Psi_d) const
{
Psi_d=0;
}

bool computeConsistentTangentOperator(const SMType smt){
using namespace std;
using namespace tfel::math;
using std::vector;
#line 104 "RambergOsgoodNonLinearElasticity.mfront"
const auto P = Stensor4::Id() - (Stensor::Id() ^ Stensor::Id()) / 3;
#line 105 "RambergOsgoodNonLinearElasticity.mfront"
if ((smt == ELASTIC) || (smt == SECANTOPERATOR)) {
#line 106 "RambergOsgoodNonLinearElasticity.mfront"
this->Dt = this->K * (Stensor::Id() ^ Stensor::Id()) + 2 * this->tum_03BC__ * P;
#line 107 "RambergOsgoodNonLinearElasticity.mfront"
} else {
#line 108 "RambergOsgoodNonLinearElasticity.mfront"
if (this->tum_03B5__tum_2091__ < this->e_tum_03B5__) {
#line 109 "RambergOsgoodNonLinearElasticity.mfront"
this->Dt = this->K * (Stensor::Id() ^ Stensor::Id()) + 2 * this->tum_03BC__ * P;
#line 110 "RambergOsgoodNonLinearElasticity.mfront"
} else {
#line 111 "RambergOsgoodNonLinearElasticity.mfront"
this->Dt = this->K * (Stensor::Id() ^ Stensor::Id()) + this->tum_2202__tum_03C3__tum_2091__tum_2215__tum_2202__tum_03B5__tum_2091__ * (this->ne ^ this->ne) +
#line 112 "RambergOsgoodNonLinearElasticity.mfront"
this->tum_03C3__tum_2091__ * this->itum_03B5__tum_2091__ * (2 * P / 3 - (this->ne ^ this->ne));
#line 113 "RambergOsgoodNonLinearElasticity.mfront"
}
#line 114 "RambergOsgoodNonLinearElasticity.mfront"
}
return true;
}

/*!
* \brief compute the sound velocity
* \param[in] rho_m0: mass density in the reference configuration
*/
speed computeSpeedOfSound(const massdensity&) const {
return speed(0);

}

const TangentOperator& getTangentOperator() const{
return this->Dt;
}

void updateExternalStateVariables(){
this->eto  += this->deto;
this->T += this->dT;
}

//!
~RambergOsgoodNonLinearElasticity()
 override = default;

private:

std::pair<bool, time> computeAPrioriTimeStepScalingFactorII() const{
return {true, this->maximal_time_step_scaling_factor};
}

std::pair<bool, time> computeAPosterioriTimeStepScalingFactorII() const{
return {true,this->maximal_time_step_scaling_factor};
}

//! policy for treating out of bounds conditions
OutOfBoundsPolicy policy = None;
}; // end of RambergOsgoodNonLinearElasticity class

template<ModellingHypothesis::Hypothesis hypothesis, typename NumericType>
std::ostream&
operator <<(std::ostream& os,const RambergOsgoodNonLinearElasticity<hypothesis, NumericType, false>& b)
{
os << "εᵗᵒ : " << b.eto << '\n';
os << "Δεᵗᵒ : " << b.deto << '\n';
os << "σ : " << b.sig << '\n';
os << "Δt : " << b.dt << '\n';
os << "E : " << b.E << '\n';
os << "ν : " << b.tum_03BD__ << '\n';
os << "n : " << b.n << '\n';
os << "α : " << b.tum_03B1__ << '\n';
os << "σ₀ : " << b.tum_03C3__tum_2080__ << '\n';
os << "σₑ : " << b.tum_03C3__tum_2091__ << '\n';
os << "Δσₑ : " << b.dtum_03C3__tum_2091__ << '\n';
os << "T : " << b.T << '\n';
os << "ΔT : " << b.dT << '\n';
os << "ne : " << b.ne << '\n';
os << "e_ε : " << b.e_tum_03B5__ << '\n';
os << "minimal_time_step_scaling_factor : " << b.minimal_time_step_scaling_factor << '\n';
os << "maximal_time_step_scaling_factor : " << b.maximal_time_step_scaling_factor << '\n';
return os;
}

/*!
* Partial specialisation for RambergOsgoodNonLinearElasticity.
*/
template<ModellingHypothesis::Hypothesis hypothesis, typename NumericType>
class MechanicalBehaviourTraits<RambergOsgoodNonLinearElasticity<hypothesis, NumericType, false> >
{
static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;
static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;
public:
static constexpr bool is_defined = true;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = N;
static constexpr unsigned short material_properties_nb = 5;
static constexpr unsigned short internal_variables_nb  = 1;
static constexpr unsigned short external_variables_nb  = 1;
static constexpr unsigned short external_variables_nb2 = 0u;
static constexpr bool hasConsistentTangentOperator = true;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = true;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "RambergOsgoodNonLinearElasticity";
}

};

/*!
* Partial specialisation for RambergOsgoodNonLinearElasticity.
*/
template<typename NumericType>
class MechanicalBehaviourTraits<RambergOsgoodNonLinearElasticity<ModellingHypothesis::AXISYMMETRICALGENERALISEDPLANESTRESS, NumericType, false> >
{
public:
static constexpr bool is_defined = false;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = 0u;
static constexpr unsigned short material_properties_nb = 0u;
static constexpr unsigned short internal_variables_nb  = 0u;
static constexpr unsigned short external_variables_nb  = 0u;
static constexpr unsigned short external_variables_nb2 = 0u;
static constexpr bool hasConsistentTangentOperator = false;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = false;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "RambergOsgoodNonLinearElasticity";
}

};

/*!
* Partial specialisation for RambergOsgoodNonLinearElasticity.
*/
template<typename NumericType>
class MechanicalBehaviourTraits<RambergOsgoodNonLinearElasticity<ModellingHypothesis::PLANESTRESS, NumericType, false> >
{
public:
static constexpr bool is_defined = false;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = 0u;
static constexpr unsigned short material_properties_nb = 0u;
static constexpr unsigned short internal_variables_nb  = 0u;
static constexpr unsigned short external_variables_nb  = 0u;
static constexpr unsigned short external_variables_nb2 = 0u;
static constexpr bool hasConsistentTangentOperator = false;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = false;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "RambergOsgoodNonLinearElasticity";
}

};

} // end of namespace tfel::material

#endif /* LIB_TFELMATERIAL_RAMBERGOSGOODNONLINEARELASTICITY_HXX */
