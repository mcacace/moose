/*!
* \file   TFEL/Material/BDT.hxx
* \brief  this file implements the BDT Behaviour.
*         File generated by tfel version 4.0.0-dev
 */

#ifndef LIB_TFELMATERIAL_BDT_HXX
#define LIB_TFELMATERIAL_BDT_HXX

#include<string>
#include<iostream>
#include<limits>
#include<stdexcept>
#include<algorithm>

#include"TFEL/Raise.hxx"
#include"TFEL/PhysicalConstants.hxx"
#include"TFEL/Config/TFELConfig.hxx"
#include"TFEL/Config/TFELTypes.hxx"
#include"TFEL/TypeTraits/IsFundamentalNumericType.hxx"
#include"TFEL/TypeTraits/IsReal.hxx"
#include"TFEL/Math/General/IEEE754.hxx"
#include"TFEL/Material/MaterialException.hxx"
#include"TFEL/Material/MechanicalBehaviour.hxx"
#include"TFEL/Material/MechanicalBehaviourTraits.hxx"
#include"TFEL/Material/OutOfBoundsPolicy.hxx"
#include"TFEL/Material/BoundsCheck.hxx"
#include"TFEL/Material/IsotropicPlasticity.hxx"
#include"TFEL/Material/Lame.hxx"
#include"TFEL/Material/Hosford1972YieldCriterion.hxx"
#include"TFEL/Material/BDTBehaviourData.hxx"
#include"TFEL/Material/BDTIntegrationData.hxx"

#include"TFEL/Math/Array/ViewsArray.hxx"
#include"TFEL/Math/tvector.hxx"
#include"TFEL/Math/Vector/tvectorIO.hxx"
#include"TFEL/Math/tmatrix.hxx"
#include"TFEL/Math/Matrix/tmatrixIO.hxx"
#include"TFEL/Math/st2tost2.hxx"
#include"TFEL/Math/ST2toST2/ST2toST2ConceptIO.hxx"
#include"TFEL/Math/TinyNewtonRaphsonSolver.hxx"
#include "MFront/GenericBehaviour/State.hxx"
#include "MFront/GenericBehaviour/BehaviourData.hxx"
namespace tfel::material{

struct BDTParametersInitializer
{
static BDTParametersInitializer&
get();

double theta;
double minimal_time_step_scaling_factor;
double maximal_time_step_scaling_factor;
double epsilon;
double numerical_jacobian_epsilon;
unsigned short iterMax;

void set(const char* const,const double);

void set(const char* const,const unsigned short);

/*!
 * \brief convert a string to double
 * \param[in] p : parameter
 * \param[in] v : value
 */
static double getDouble(const std::string&,const std::string&);
/*!
 * \brief convert a string to unsigned short
 * \param[in] p : parameter
 * \param[in] v : value
 */
static unsigned short getUnsignedShort(const std::string&,const std::string&);
private :

BDTParametersInitializer();

BDTParametersInitializer(const BDTParametersInitializer&);

BDTParametersInitializer&
operator=(const BDTParametersInitializer&);
/*!
 * \brief read the parameters from the given file
 * \param[out] pi : parameters initializer
 * \param[in]  fn : file name
 */
static void readParameters(BDTParametersInitializer&,const char* const);
};

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis, typename NumericType, bool use_qt>
class BDT;

//! \brief forward declaration
template<ModellingHypothesis::Hypothesis hypothesis, typename NumericType>
std::ostream&
 operator <<(std::ostream&,const BDT<hypothesis, NumericType, false>&);

/*!
* \class BDT
* \brief This class implements the BDT behaviour.
* \tparam hypothesis: modelling hypothesis.
* \tparam NumericType: numerical type.
*/
template<ModellingHypothesis::Hypothesis hypothesis,typename NumericType>
struct BDT<hypothesis, NumericType, false> final
: public MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>,
public BDTBehaviourData<hypothesis, NumericType, false>,
public BDTIntegrationData<hypothesis, NumericType, false>,
public tfel::math::TinyNewtonRaphsonSolver<6 + ModellingHypothesisToStensorSize<hypothesis>::value, NumericType, BDT<hypothesis, NumericType, false>>{

static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;

static_assert(N==1||N==2||N==3);
static_assert(tfel::typetraits::IsFundamentalNumericType<NumericType>::cond);
static_assert(tfel::typetraits::IsReal<NumericType>::cond);

friend std::ostream& operator<< <>(std::ostream&,const BDT&);

friend struct tfel::math::TinyNonLinearSolverBase<6 + ModellingHypothesisToStensorSize<hypothesis>::value, NumericType, BDT>;
static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;

using ushort =  unsigned short;
using Types = tfel::config::Types<N, NumericType, false>;
using Type = NumericType;
using real = typename Types::real;
using time = typename Types::time;
using length = typename Types::length;
using frequency = typename Types::frequency;
using speed = typename Types::speed;
using stress = typename Types::stress;
using strain = typename Types::strain;
using strainrate = typename Types::strainrate;
using stressrate = typename Types::stressrate;
using temperature = typename Types::temperature;
using thermalexpansion = typename Types::thermalexpansion;
using thermalconductivity = typename Types::thermalconductivity;
using massdensity = typename Types::massdensity;
using energydensity = typename Types::energydensity;
using TVector = typename Types::TVector;
using DisplacementTVector = typename Types::DisplacementTVector;
using ForceTVector = typename Types::ForceTVector;
using HeatFlux = typename Types::HeatFlux;
using TemperatureGradient = typename Types::TemperatureGradient;
using Stensor = typename Types::Stensor;
using StressStensor = typename Types::StressStensor;
using StressRateStensor = typename Types::StressRateStensor;
using StrainStensor = typename Types::StrainStensor;
using StrainRateStensor = typename Types::StrainRateStensor;
using FrequencyStensor = typename Types::FrequencyStensor;
using Tensor = typename Types::Tensor;
using DeformationGradientTensor = typename Types::DeformationGradientTensor;
using StressTensor = typename Types::StressTensor;
using StiffnessTensor = typename Types::StiffnessTensor;
using Stensor4 = typename Types::Stensor4;
using TangentOperator = StiffnessTensor;
using PhysicalConstants = tfel::PhysicalConstants<NumericType, false>;

public :

typedef BDTBehaviourData<hypothesis, NumericType, false> BehaviourData;
typedef BDTIntegrationData<hypothesis, NumericType, false> IntegrationData;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::SMFlag SMFlag;
typedef typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::SMType SMType;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::ELASTIC;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::SECANTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::TANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::CONSISTENTTANGENTOPERATOR;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::NOSTIFFNESSREQUESTED;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::STANDARDTANGENTOPERATOR;
using IntegrationResult = typename MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::IntegrationResult;

using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::SUCCESS;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::FAILURE;
using MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::UNRELIABLE_RESULTS;

using StressFreeExpansionType = StrainStensor;

private :



tfel::math::View<StrainStensor> deel;
#line 39 "BDT.mfront"
real& dpla_mult;
#line 40 "BDT.mfront"
real& da;
#line 41 "BDT.mfront"
real& ddam;
#line 42 "BDT.mfront"
real& dRv;
#line 43 "BDT.mfront"
real& dtriax_p;
#line 44 "BDT.mfront"
real& dvp;

#line 46 "BDT.mfront"
stress lambda;
#line 47 "BDT.mfront"
stress mu;
#line 48 "BDT.mfront"
stress Fel;
#line 49 "BDT.mfront"
StressStensor s0;

NumericType theta;
time minimal_time_step_scaling_factor;
time maximal_time_step_scaling_factor;
NumericType epsilon;
NumericType numerical_jacobian_epsilon;
ushort iterMax;

//! Tangent operator;
TangentOperator Dt;
//! alias to the tangent operator;
TangentOperator& dsig_ddeto;
// updating material properties, in mandatory
void updateMaterialPropertiesDependantOnStateVariables(){
using namespace std;
using namespace tfel::math;
using std::vector;
}

SMType stiffness_matrix_type;
void computeNumericalJacobian(tfel::math::tmatrix<6 + StensorSize,6 + StensorSize, NumericType>& njacobian)
{
using namespace std;
using namespace tfel::math;
tvector<6 + StensorSize, NumericType> tzeros(this->zeros);
tvector<6 + StensorSize, NumericType> tfzeros(this->fzeros);
tmatrix<6 + StensorSize,6 + StensorSize, NumericType> tjacobian(this->jacobian);
for(unsigned short idx = 0; idx!= 6 + StensorSize;++idx){
this->zeros(idx) -= this->numerical_jacobian_epsilon;
this->computeThermodynamicForces();
this->computeFdF(true);
this->zeros = tzeros;
tvector<6 + StensorSize, NumericType> tfzeros2(this->fzeros);
this->zeros(idx) += this->numerical_jacobian_epsilon;
this->computeThermodynamicForces();
this->computeFdF(true);
this->fzeros = (this->fzeros-tfzeros2) / (2 * (this->numerical_jacobian_epsilon));
for(unsigned short idx2 = 0; idx2!= 6 + StensorSize;++idx2){
njacobian(idx2,idx) = this->fzeros(idx2);
}
this->zeros    = tzeros;
this->fzeros   = tfzeros;
}
if(&njacobian!=&(this->jacobian)){
this->jacobian = tjacobian;
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<6 + StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<6 + StensorSize, NumericType> vect_e(NumericType(0));
vect_e(idx) = NumericType(1);
TinyMatrixSolve<6 + StensorSize, NumericType>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0u;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<6 + StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_pla_mult)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<6 + StensorSize, NumericType> vect_e(NumericType(0));
vect_e(idx) = NumericType(1);
TinyMatrixSolve<6 + StensorSize, NumericType>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0u;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
partial_jacobian_pla_mult(idx)=vect_e(StensorSize);
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<6 + StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_pla_mult,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_a)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<6 + StensorSize, NumericType> vect_e(NumericType(0));
vect_e(idx) = NumericType(1);
TinyMatrixSolve<6 + StensorSize, NumericType>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0u;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
partial_jacobian_pla_mult(idx)=vect_e(StensorSize);
partial_jacobian_a(idx)=vect_e(1 + StensorSize);
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<6 + StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_pla_mult,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_a,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_dam)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<6 + StensorSize, NumericType> vect_e(NumericType(0));
vect_e(idx) = NumericType(1);
TinyMatrixSolve<6 + StensorSize, NumericType>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0u;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
partial_jacobian_pla_mult(idx)=vect_e(StensorSize);
partial_jacobian_a(idx)=vect_e(1 + StensorSize);
partial_jacobian_dam(idx)=vect_e(2 + StensorSize);
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<6 + StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_pla_mult,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_a,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_dam,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_Rv)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<6 + StensorSize, NumericType> vect_e(NumericType(0));
vect_e(idx) = NumericType(1);
TinyMatrixSolve<6 + StensorSize, NumericType>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0u;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
partial_jacobian_pla_mult(idx)=vect_e(StensorSize);
partial_jacobian_a(idx)=vect_e(1 + StensorSize);
partial_jacobian_dam(idx)=vect_e(2 + StensorSize);
partial_jacobian_Rv(idx)=vect_e(3 + StensorSize);
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<6 + StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_pla_mult,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_a,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_dam,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_Rv,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_triax_p)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<6 + StensorSize, NumericType> vect_e(NumericType(0));
vect_e(idx) = NumericType(1);
TinyMatrixSolve<6 + StensorSize, NumericType>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0u;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
partial_jacobian_pla_mult(idx)=vect_e(StensorSize);
partial_jacobian_a(idx)=vect_e(1 + StensorSize);
partial_jacobian_dam(idx)=vect_e(2 + StensorSize);
partial_jacobian_Rv(idx)=vect_e(3 + StensorSize);
partial_jacobian_triax_p(idx)=vect_e(4 + StensorSize);
}
}

void
computePartialJacobianInvert(const tfel::math::TinyPermutation<6 + StensorSize>& jacobian_permutation, tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_pla_mult,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_a,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_dam,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_Rv,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_triax_p,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_vp)
{
using namespace tfel::math;
for(unsigned short idx=0;idx!=StensorSize;++idx){
tvector<6 + StensorSize, NumericType> vect_e(NumericType(0));
vect_e(idx) = NumericType(1);
TinyMatrixSolve<6 + StensorSize, NumericType>::back_substitute(this->jacobian,jacobian_permutation,vect_e);
for(unsigned short idx2=0u;idx2!=StensorSize;++idx2){
partial_jacobian_eel(idx2,idx)=vect_e(idx2);
}
partial_jacobian_pla_mult(idx)=vect_e(StensorSize);
partial_jacobian_a(idx)=vect_e(1 + StensorSize);
partial_jacobian_dam(idx)=vect_e(2 + StensorSize);
partial_jacobian_Rv(idx)=vect_e(3 + StensorSize);
partial_jacobian_triax_p(idx)=vect_e(4 + StensorSize);
partial_jacobian_vp(idx)=vect_e(5 + StensorSize);
}
}

void computeThermodynamicForces(){
using namespace std;
using namespace tfel::math;
using std::vector;
#line 86 "BDT.mfront"
this->sig = (1 - (this->dam+(this->theta)*(this->ddam))) * (this->lambda * trace((this->eel+(this->theta)*(this->deel))) * Stensor::Id() + 2 * this->mu * (this->eel+(this->theta)*(this->deel)));
} // end of BDT::computeThermodynamicForces

void computeFinalThermodynamicForces(){
using namespace std;
using namespace tfel::math;
using std::vector;
#line 86 "BDT.mfront"
this->sig = (1 - this->dam) * (this->lambda * trace(this->eel) * Stensor::Id() + 2 * this->mu * this->eel);
} // end of BDT::computeFinalThermodynamicForces

/*!
* \brief Update internal variables at end of integration
*/
void updateIntegrationVariables(){
}

/*!
* \brief Update internal variables at end of integration
*/
void updateStateVariables(){
this->eel += this->deel;
this->pla_mult += this->dpla_mult;
this->a += this->da;
this->dam += this->ddam;
this->Rv += this->dRv;
this->triax_p += this->dtriax_p;
this->vp += this->dvp;
}

/*!
* \brief Update auxiliary state variables at end of integration
*/
void updateAuxiliaryStateVariables()
{}

//! \brief Default constructor (disabled)
BDT() =delete ;
//! \brief Copy constructor (disabled)
BDT(const BDT&) = delete;
//! \brief Assignement operator (disabled)
BDT& operator = (const BDT&) = delete;

public:

/*!
* \brief Constructor
*/
BDT(const BDTBehaviourData<hypothesis, NumericType, false>& src1,
const BDTIntegrationData<hypothesis, NumericType, false>& src2)
: BDTBehaviourData<hypothesis, NumericType, false>(src1),
BDTIntegrationData<hypothesis, NumericType, false>(src2),
deel(tfel::math::map<StrainStensor, 0u>(this->zeros)),
dpla_mult(this->zeros(StensorSize)),
da(this->zeros(1 + StensorSize)),
ddam(this->zeros(2 + StensorSize)),
dRv(this->zeros(3 + StensorSize)),
dtriax_p(this->zeros(4 + StensorSize)),
dvp(this->zeros(5 + StensorSize)),
dsig_ddeto(Dt)
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->theta = BDTParametersInitializer::get().theta;
this->minimal_time_step_scaling_factor = BDTParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = BDTParametersInitializer::get().maximal_time_step_scaling_factor;
this->epsilon = BDTParametersInitializer::get().epsilon;
this->numerical_jacobian_epsilon = BDTParametersInitializer::get().numerical_jacobian_epsilon;
this->iterMax = BDTParametersInitializer::get().iterMax;
}

/*
 * \brief constructor for the Generic interface
 * \param[in] mgb_d: behaviour data
 */
BDT(const mfront::gb::BehaviourData& mgb_d)
: BDTBehaviourData<hypothesis, NumericType, false>(mgb_d),
BDTIntegrationData<hypothesis, NumericType, false>(mgb_d),
deel(tfel::math::map<StrainStensor, 0u>(this->zeros)),
dpla_mult(this->zeros(StensorSize)),
da(this->zeros(1 + StensorSize)),
ddam(this->zeros(2 + StensorSize)),
dRv(this->zeros(3 + StensorSize)),
dtriax_p(this->zeros(4 + StensorSize)),
dvp(this->zeros(5 + StensorSize)),
dsig_ddeto(Dt)
{
using namespace std;
using namespace tfel::math;
using std::vector;
this->theta = BDTParametersInitializer::get().theta;
this->minimal_time_step_scaling_factor = BDTParametersInitializer::get().minimal_time_step_scaling_factor;
this->maximal_time_step_scaling_factor = BDTParametersInitializer::get().maximal_time_step_scaling_factor;
this->epsilon = BDTParametersInitializer::get().epsilon;
this->numerical_jacobian_epsilon = BDTParametersInitializer::get().numerical_jacobian_epsilon;
this->iterMax = BDTParametersInitializer::get().iterMax;
this-> eto = tfel::math::map<StrainStensor>(mgb_d.s0.gradients);
tfel::fsalgo::transform<StensorSize>::exe(mgb_d.s1.gradients,mgb_d.s0.gradients,this->deto.begin(),std::minus<real>());
this-> sig = tfel::math::map<StressStensor>(mgb_d.s0.thermodynamic_forces);
}

/*!
 * \ brief initialize the behaviour with user code
 */
void initialize(){
using namespace std;
using namespace tfel::math;
using std::vector;
#line 56 "BDT.mfront"
auto const T_Celsius = this->T - 273.15;
#line 58 "BDT.mfront"
const auto y2 = this->El_1 * power<2>(T_Celsius) + this->El_2 * T_Celsius + this->El_3;
#line 59 "BDT.mfront"
this->lambda = computeLambda(this->young * y2, this->nu);
#line 60 "BDT.mfront"
this->mu = computeMu(this->young * y2, this->nu);
#line 61 "BDT.mfront"
StressStensor sigel(this->lambda * trace(this->eel + this->deto) * Stensor::Id() +
#line 62 "BDT.mfront"
2 * this->mu * (this->eel + this->deto));
#line 63 "BDT.mfront"
const auto s_dev = deviator(sigel);
#line 65 "BDT.mfront"
const stress seq = sigmaeq(s_dev);
#line 66 "BDT.mfront"
const stress I1 = trace(sigel);
#line 67 "BDT.mfront"
const auto aux = (seq + I1) / (3. * this->f_c);
#line 69 "BDT.mfront"
const auto aux_ex = (1. - 1. / this->n_exp_T);
#line 70 "BDT.mfront"
const auto aux_arg = 1 + pow(this->alpha_p * (T_Celsius - 10.), this->n_exp_T);
#line 72 "BDT.mfront"
this->Rv = max(this->at_1 * T_Celsius + this->at_2 * I1 / 3. + this->at_3, 1.0e-4);
#line 73 "BDT.mfront"
auto Rpel = -(1. - this->q_h0) * pow((this->a + this->vp) / this->Rv, 2) +
#line 74 "BDT.mfront"
2. * (1. - this->q_h0) * (this->a + this->vp) / this->Rv + this->q_h0;
#line 75 "BDT.mfront"
if ((this->a + this->vp) > this->Rv)
#line 76 "BDT.mfront"
Rpel = 1.0;
#line 78 "BDT.mfront"
const auto q_h = Rpel / (pow(aux_arg, aux_ex));
#line 80 "BDT.mfront"
this->Fel = power<2>((1. - q_h) * power<2>(aux) + seq / this->f_c) +
#line 81 "BDT.mfront"
(this->m_0 * aux - 1) * power<2>(q_h);
}

/*!
* \brief set the policy for "out of bounds" conditions
*/
void
setOutOfBoundsPolicy(const OutOfBoundsPolicy policy_value){
this->policy = policy_value;
} // end of setOutOfBoundsPolicy

/*!
* \return the modelling hypothesis
*/
constexpr ModellingHypothesis::Hypothesis
getModellingHypothesis() const{
return hypothesis;
} // end of getModellingHypothesis

/*!
* \brief check bounds
*/
void checkBounds() const{
} // end of checkBounds

IntegrationResult computePredictionOperator(const SMFlag,const SMType) override{
tfel::raise("BDT::computePredictionOperator: "
"unsupported prediction operator flag");
}

time getMinimalTimeStepScalingFactor() const noexcept override{
  return this->minimal_time_step_scaling_factor;
}

std::pair<bool, time>
computeAPrioriTimeStepScalingFactor(const time current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPrioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                  current_time_step_scaling_factor)};
}

/*!
 * \brief Integrate behaviour law over the time step
 */
IntegrationResult integrate(const SMFlag smflag,const SMType smt) override{
using namespace std;
using namespace tfel::math;
this->stiffness_matrix_type = smt;
tfel::raise_if(smflag!=MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::STANDARDTANGENTOPERATOR,
"invalid tangent operator flag");
tfel::math::TinyNewtonRaphsonSolver<6 + ModellingHypothesisToStensorSize<hypothesis>::value, NumericType, BDT<hypothesis, NumericType, false>>::epsilon = this->epsilon;
tfel::math::TinyNewtonRaphsonSolver<6 + ModellingHypothesisToStensorSize<hypothesis>::value, NumericType, BDT<hypothesis, NumericType, false>>::iterMax = this->iterMax;
if(!this->solveNonLinearSystem()){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::FAILURE;
}
if (this->stiffness_matrix_type != NOSTIFFNESSREQUESTED){
this->updateOrCheckJacobian();
}
this->updateIntegrationVariables();
this->updateStateVariables();
this->computeFinalThermodynamicForces();
this->updateAuxiliaryStateVariables();
if(smt!=NOSTIFFNESSREQUESTED){
if(!this->computeConsistentTangentOperator(smt)){
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::FAILURE;
}
}
return MechanicalBehaviour<MechanicalBehaviourBase::STANDARDSTRAINBASEDBEHAVIOUR,hypothesis, NumericType, false>::SUCCESS;
} // end of BDT::integrate

bool computeResidual(){
this->computeThermodynamicForces();
return this->computeFdF(false);
}
//! \return the norm of the residual
NumericType computeResidualNorm() {
return tfel::math::norm(this->fzeros) / (6 + StensorSize);
}
/*!
 * \brief check the convergence of the method
 * \param[in] error: current error
 */
bool checkConvergence(const NumericType error) {
auto converged = error < this->epsilon;
return converged;
}
/*!
 * \brief update the jacobian matrix if required.
 * \param[in] converged: boolean stating if the method is
 * called after the convergence of the algorithm or before  * the computation of the next correction.
 *
 * This method can be used to compute the jacobian or part  * of the jacobian numerically. If the jacobian was computed
 * in `computeResidual`, this method can be used to compare it  * to a numerical approximation.
 */
void updateOrCheckJacobian(){
this->computeNumericalJacobian(this->jacobian);
};
/*!
 * \brief method meant to set bounds on some components  * of the current Newton correction or to implement a line  * search.
 */
void processNewCorrection()
{
};
/*!
 * \brief method meant to process the new estimate.
 *
 * This method may be called to apply bounds on the  * new estimate.
 */
void processNewEstimate(){
this->updateMaterialPropertiesDependantOnStateVariables();
}
/*!
 * \brief solve linear system
 * \return true on success
 * \param[in] m: matrix
 * \param[in,out] v: right hand side on input, solution on output
 */
bool solveLinearSystem(tfel::math::tmatrix<6 + StensorSize, 6 + StensorSize, NumericType>& mfront_matrix,tfel::math::tvector<6 + StensorSize, NumericType>& mfront_vector)const noexcept{
auto mfront_success = true;
mfront_success = tfel::math::TinyMatrixSolve<6 + StensorSize, NumericType, false>::exe(mfront_matrix, mfront_vector);
return mfront_success;
}
/*!
* \brief compute fzeros and jacobian
*/
bool computeFdF(const bool perturbatedSystemEvaluation){
using namespace std;
using namespace tfel::math;
using std::vector;
// silent compiler warning
static_cast<void>(perturbatedSystemEvaluation); 
constexpr auto eel_offset = 0u;
static_cast<void>(eel_offset);
auto feel = tfel::math::map<StrainStensor, 0u>(this->fzeros);
constexpr auto pla_mult_offset = StensorSize;
static_cast<void>(pla_mult_offset);
real& fpla_mult(this->fzeros(StensorSize));
constexpr auto a_offset = 1 + StensorSize;
static_cast<void>(a_offset);
real& fa(this->fzeros(1 + StensorSize));
constexpr auto dam_offset = 2 + StensorSize;
static_cast<void>(dam_offset);
real& fdam(this->fzeros(2 + StensorSize));
constexpr auto Rv_offset = 3 + StensorSize;
static_cast<void>(Rv_offset);
real& fRv(this->fzeros(3 + StensorSize));
constexpr auto triax_p_offset = 4 + StensorSize;
static_cast<void>(triax_p_offset);
real& ftriax_p(this->fzeros(4 + StensorSize));
constexpr auto vp_offset = 5 + StensorSize;
static_cast<void>(vp_offset);
real& fvp(this->fzeros(5 + StensorSize));
// setting f values to zeros
this->fzeros = this->zeros;
#line 91 "BDT.mfront"
auto const T_Celsius = (this->T) - 273.15;
#line 93 "BDT.mfront"
Stensor nvp = Stensor(0.);
#line 94 "BDT.mfront"
Stensor s_dev = deviator((this->sig) / (1 - (this->dam)));
#line 95 "BDT.mfront"
const stress seq = sigmaeq(s_dev);
#line 97 "BDT.mfront"
if (seq > 1.e-15)
#line 98 "BDT.mfront"
{
#line 99 "BDT.mfront"
nvp = 1.5 * s_dev / seq;
#line 100 "BDT.mfront"
}
#line 101 "BDT.mfront"
fvp -=
#line 102 "BDT.mfront"
(this->dt) * (this->A_creep) * exp(-(this->Qact) / 8.3144598 / T_Celsius) * pow(seq, (this->n_creep));
#line 104 "BDT.mfront"
if ((this->Fel) > 0)
#line 105 "BDT.mfront"
{
#line 106 "BDT.mfront"
Stensor nq = s_dev;
#line 107 "BDT.mfront"
Stensor np = 1.0 * Stensor::Id();
#line 108 "BDT.mfront"
const auto aux = (seq + trace((this->sig) / (1 - (this->dam)))) / (3. * (this->f_c));
#line 110 "BDT.mfront"
const auto aux_ex = (1. - 1. / (this->n_exp_T));
#line 111 "BDT.mfront"
const auto aux_arg = 1 + pow((this->alpha_p) * (T_Celsius - 10), (this->n_exp_T));
#line 112 "BDT.mfront"
real a_;
#line 113 "BDT.mfront"
real vp_;
#line 115 "BDT.mfront"
a_ = (this->a) + theta * (this->da);
#line 116 "BDT.mfront"
vp_ = (this->vp) + theta * (this->dvp);
#line 117 "BDT.mfront"
(this->Rv) = max((this->at_1) * T_Celsius + (this->at_2) * trace((this->sig) / (1 - (this->dam))) / 3. + (this->at_3),
#line 118 "BDT.mfront"
1.0e-4);
#line 119 "BDT.mfront"
auto Rp_ = -(1. - (this->q_h0)) * pow((a_ + vp_) / (this->Rv), 2) +
#line 120 "BDT.mfront"
2. * (1. - (this->q_h0)) * (a_ + vp_) / (this->Rv) + (this->q_h0);
#line 121 "BDT.mfront"
if ((a_ + vp_) > (this->Rv))
#line 122 "BDT.mfront"
Rp_ = 1.0;
#line 123 "BDT.mfront"
const auto q_h = Rp_ / (pow(aux_arg, aux_ex));
#line 125 "BDT.mfront"
const auto yield = power<2>((1. - q_h) * power<2>(aux) + seq / (this->f_c)) +
#line 126 "BDT.mfront"
((this->m_0) * aux - 1) * power<2>(q_h);
#line 128 "BDT.mfront"
const auto big_aux = power<2>(aux) * (1 - q_h) + seq / (this->f_c);
#line 129 "BDT.mfront"
const auto dev_flow =
#line 130 "BDT.mfront"
power<2>(q_h) * (this->m_0) / (2. * (this->f_c) * seq) +
#line 131 "BDT.mfront"
2. * ((1 - q_h) * aux / ((this->f_c) * seq) + 3. / (2. * (this->f_c) * seq)) *
#line 132 "BDT.mfront"
big_aux;
#line 133 "BDT.mfront"
const auto iso_flow = power<2>(q_h) * (this->m_0) / (3. * (this->f_c)) +
#line 134 "BDT.mfront"
4. * (1. - q_h) * aux / (3. * (this->f_c)) * big_aux;
#line 136 "BDT.mfront"
feel = (this->deel) - (this->deto) + (this->dpla_mult) * (nq * dev_flow + np * iso_flow) +
#line 137 "BDT.mfront"
(this->dvp) * nvp;
#line 138 "BDT.mfront"
fpla_mult = yield / (this->young);
#line 139 "BDT.mfront"
fa = (this->da) - sqrt(2. / 3. * ((this->dpla_mult) * (nq * dev_flow + np * iso_flow)) |
#line 140 "BDT.mfront"
((this->dpla_mult) * (nq * dev_flow + np * iso_flow)));
#line 141 "BDT.mfront"
(this->triax_p) = iso_flow / dev_flow;
#line 143 "BDT.mfront"
(this->dam) = max(min(1 - exp(-((((this->a) + (this->vp)) - (this->Rv)) / (this->alpha_d))), 1.0), 0.0);
#line 144 "BDT.mfront"
(this->sig) = (1 - (this->dam)) * (this->sig);
#line 145 "BDT.mfront"
}
#line 146 "BDT.mfront"
else
#line 147 "BDT.mfront"
{
#line 148 "BDT.mfront"
feel = (this->deel) - (this->deto) + (this->dvp) * nvp;
#line 149 "BDT.mfront"
}
return true;
}

std::pair<bool, time>
computeAPosterioriTimeStepScalingFactor(const time current_time_step_scaling_factor) const override{
const auto time_scaling_factor = this->computeAPosterioriTimeStepScalingFactorII();
return {time_scaling_factor.first,
        std::min(std::min(std::max(time_scaling_factor.second,
                                   this->minimal_time_step_scaling_factor),
                          this->maximal_time_step_scaling_factor),
                 current_time_step_scaling_factor)};
}

/*!
* \brief Update the internal energy at end of the time step
* \param[in] Psi_s: internal energy at end of the time step
*/
void computeInternalEnergy(real& Psi_s) const
{
Psi_s=0;
}

/*!
* \brief Update the dissipated energy at end of the time step
* \param[in] Psi_d: dissipated energy at end of the time step
*/
void computeDissipatedEnergy(real& Psi_d) const
{
Psi_d=0;
}

bool computeConsistentTangentOperator(const SMType smt){
using namespace std;
using namespace tfel::math;
using std::vector;
TinyPermutation<6 + StensorSize> jacobian_permutation;
TinyMatrixSolve<6 + StensorSize, NumericType>::decomp(this->jacobian,jacobian_permutation);
struct TFEL_VISIBILITY_LOCAL GetPartialJacobianInvert{
GetPartialJacobianInvert(BDT& b,
const tfel::math::TinyPermutation<6 + StensorSize>& p)
: behaviour(b),
permutation(p)
{}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel);
}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_pla_mult){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel,
partial_jacobian_pla_mult);
}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_pla_mult,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_a){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel,
partial_jacobian_pla_mult,
partial_jacobian_a);
}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_pla_mult,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_a,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_dam){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel,
partial_jacobian_pla_mult,
partial_jacobian_a,
partial_jacobian_dam);
}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_pla_mult,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_a,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_dam,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_Rv){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel,
partial_jacobian_pla_mult,
partial_jacobian_a,
partial_jacobian_dam,
partial_jacobian_Rv);
}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_pla_mult,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_a,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_dam,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_Rv,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_triax_p){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel,
partial_jacobian_pla_mult,
partial_jacobian_a,
partial_jacobian_dam,
partial_jacobian_Rv,
partial_jacobian_triax_p);
}
void operator()(tfel::math::derivative_type<StrainStensor, StrainStensor>& partial_jacobian_eel,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_pla_mult,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_a,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_dam,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_Rv,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_triax_p,
tfel::math::derivative_type<real, StrainStensor>& partial_jacobian_vp){
this->behaviour.computePartialJacobianInvert(this->permutation, partial_jacobian_eel,
partial_jacobian_pla_mult,
partial_jacobian_a,
partial_jacobian_dam,
partial_jacobian_Rv,
partial_jacobian_triax_p,
partial_jacobian_vp);
}
private:
BDT& behaviour;
const tfel::math::TinyPermutation<6 + StensorSize>& permutation;
}; // end of struct GetPartialJacobianInvert
GetPartialJacobianInvert getPartialJacobianInvert(*this, jacobian_permutation);
#line 154 "BDT.mfront"
if ((smt == ELASTIC) || (smt == SECANTOPERATOR))
#line 155 "BDT.mfront"
{
#line 156 "BDT.mfront"
computeElasticStiffness<N, Type>::exe((this->Dt), (this->lambda), (this->mu));
#line 157 "BDT.mfront"
}
#line 158 "BDT.mfront"
else if (smt == CONSISTENTTANGENTOPERATOR)
#line 159 "BDT.mfront"
{
#line 160 "BDT.mfront"
StiffnessTensor De;
#line 161 "BDT.mfront"
Stensor4 Je;
#line 162 "BDT.mfront"
computeElasticStiffness<N, Type>::exe(De, (this->lambda), (this->mu));
#line 163 "BDT.mfront"
getPartialJacobianInvert(Je);
#line 164 "BDT.mfront"
(this->Dt) = De * Je;
#line 165 "BDT.mfront"
}
#line 166 "BDT.mfront"
else
#line 167 "BDT.mfront"
{
#line 168 "BDT.mfront"
return false;
#line 169 "BDT.mfront"
}
return true;
}

/*!
* \brief compute the sound velocity
* \param[in] rho_m0: mass density in the reference configuration
*/
speed computeSpeedOfSound(const massdensity&) const {
return speed(0);

}

const TangentOperator& getTangentOperator() const{
return this->Dt;
}

void updateExternalStateVariables(){
this->eto  += this->deto;
this->T += this->dT;
}

//!
~BDT()
 override = default;

private:

std::pair<bool, time> computeAPrioriTimeStepScalingFactorII() const{
return {true, this->maximal_time_step_scaling_factor};
}

std::pair<bool, time> computeAPosterioriTimeStepScalingFactorII() const{
return {true,this->maximal_time_step_scaling_factor};
}

//! policy for treating out of bounds conditions
OutOfBoundsPolicy policy = None;
}; // end of BDT class

template<ModellingHypothesis::Hypothesis hypothesis, typename NumericType>
std::ostream&
operator <<(std::ostream& os,const BDT<hypothesis, NumericType, false>& b)
{
os << "εᵗᵒ : " << b.eto << '\n';
os << "Δεᵗᵒ : " << b.deto << '\n';
os << "σ : " << b.sig << '\n';
os << "Δt : " << b.dt << '\n';
os << "young : " << b.young << '\n';
os << "nu : " << b.nu << '\n';
os << "alpha : " << b.alpha << '\n';
os << "f_c : " << b.f_c << '\n';
os << "m_0 : " << b.m_0 << '\n';
os << "alpha_p : " << b.alpha_p << '\n';
os << "n_exp_T : " << b.n_exp_T << '\n';
os << "q_h0 : " << b.q_h0 << '\n';
os << "chi_h : " << b.chi_h << '\n';
os << "alpha_d : " << b.alpha_d << '\n';
os << "h_d : " << b.h_d << '\n';
os << "Qact : " << b.Qact << '\n';
os << "A_creep : " << b.A_creep << '\n';
os << "n_creep : " << b.n_creep << '\n';
os << "El_1 : " << b.El_1 << '\n';
os << "El_2 : " << b.El_2 << '\n';
os << "El_3 : " << b.El_3 << '\n';
os << "at_1 : " << b.at_1 << '\n';
os << "at_2 : " << b.at_2 << '\n';
os << "at_3 : " << b.at_3 << '\n';
os << "εᵉˡ : " << b.eel << '\n';
os << "Δεᵉˡ : " << b.deel << '\n';
os << "pla_mult : " << b.pla_mult << '\n';
os << "Δpla_mult : " << b.dpla_mult << '\n';
os << "a : " << b.a << '\n';
os << "Δa : " << b.da << '\n';
os << "dam : " << b.dam << '\n';
os << "Δdam : " << b.ddam << '\n';
os << "Rv : " << b.Rv << '\n';
os << "ΔRv : " << b.dRv << '\n';
os << "triax_p : " << b.triax_p << '\n';
os << "Δtriax_p : " << b.dtriax_p << '\n';
os << "vp : " << b.vp << '\n';
os << "Δvp : " << b.dvp << '\n';
os << "T : " << b.T << '\n';
os << "ΔT : " << b.dT << '\n';
os << "s0 : " << b.s0 << '\n';
os << "θ : " << b.theta << '\n';
os << "minimal_time_step_scaling_factor : " << b.minimal_time_step_scaling_factor << '\n';
os << "maximal_time_step_scaling_factor : " << b.maximal_time_step_scaling_factor << '\n';
os << "ε : " << b.epsilon << '\n';
os << "numerical_jacobian_epsilon : " << b.numerical_jacobian_epsilon << '\n';
os << "iterMax : " << b.iterMax << '\n';
return os;
}

/*!
* Partial specialisation for BDT.
*/
template<ModellingHypothesis::Hypothesis hypothesis, typename NumericType>
class MechanicalBehaviourTraits<BDT<hypothesis, NumericType, false> >
{
static constexpr unsigned short N = ModellingHypothesisToSpaceDimension<hypothesis>::value;
static constexpr unsigned short TVectorSize = N;
typedef tfel::math::StensorDimeToSize<N> StensorDimeToSize;
static constexpr unsigned short StensorSize = StensorDimeToSize::value;
typedef tfel::math::TensorDimeToSize<N> TensorDimeToSize;
static constexpr unsigned short TensorSize = TensorDimeToSize::value;
public:
static constexpr bool is_defined = true;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = N;
static constexpr unsigned short material_properties_nb = 20;
static constexpr unsigned short internal_variables_nb  = 6 + StensorSize;
static constexpr unsigned short external_variables_nb  = 1;
static constexpr unsigned short external_variables_nb2 = 0u;
static constexpr bool hasConsistentTangentOperator = true;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = false;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "BDT";
}

};

/*!
* Partial specialisation for BDT.
*/
template<typename NumericType>
class MechanicalBehaviourTraits<BDT<ModellingHypothesis::AXISYMMETRICALGENERALISEDPLANESTRESS, NumericType, false> >
{
public:
static constexpr bool is_defined = false;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = 0u;
static constexpr unsigned short material_properties_nb = 0u;
static constexpr unsigned short internal_variables_nb  = 0u;
static constexpr unsigned short external_variables_nb  = 0u;
static constexpr unsigned short external_variables_nb2 = 0u;
static constexpr bool hasConsistentTangentOperator = false;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = false;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "BDT";
}

};

/*!
* Partial specialisation for BDT.
*/
template<typename NumericType>
class MechanicalBehaviourTraits<BDT<ModellingHypothesis::PLANESTRESS, NumericType, false> >
{
public:
static constexpr bool is_defined = false;
static constexpr bool use_quantities = false;
static constexpr bool hasStressFreeExpansion = false;
static constexpr bool handlesThermalExpansion = false;
static constexpr unsigned short dimension = 0u;
static constexpr unsigned short material_properties_nb = 0u;
static constexpr unsigned short internal_variables_nb  = 0u;
static constexpr unsigned short external_variables_nb  = 0u;
static constexpr unsigned short external_variables_nb2 = 0u;
static constexpr bool hasConsistentTangentOperator = false;
static constexpr bool isConsistentTangentOperatorSymmetric = false;
static constexpr bool hasPredictionOperator = false;
static constexpr bool hasAPrioriTimeStepScalingFactor = false;
static constexpr bool hasComputeInternalEnergy = false;
static constexpr bool hasComputeDissipatedEnergy = false;
/*!
* \return the name of the class.
*/
static const char* getName(){
return "BDT";
}

};

} // end of namespace tfel::material

#endif /* LIB_TFELMATERIAL_BDT_HXX */
